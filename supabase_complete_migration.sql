-- ====================================================================
-- VINCONS APP - UNIFIED MIGRATION SCRIPT (VERIFIED V2)
-- ====================================================================
-- This script sets up the complete database schema for the application.
-- It handles:
-- 1. Core Tables (Machines, Projects, Users)
-- 2. Operational Tables (Logs, Repair History, Maintenance History)
-- 3. Technical Tables (Error Codes, Parts, Standards)
-- 4. Utility Tables (Notifications)
-- 5. Automation (Triggers, Smart Import Function)
-- 6. Initial Data Seeding
--
-- FIX: Includes explicit migration for legacy tables (adding machine_id)
-- ====================================================================

-- 1. ENABLE EXTENSIONS
create extension if not exists "uuid-ossp";

-- 2. CREATE/UPDATE TABLES

-- [PROJECTS] ---------------------------------------------------------
create table if not exists projects (
    id SERIAL PRIMARY KEY,
    code text,
    name text not null,
    address text,
    start_date date,
    end_date date,
    status text default 'active', -- active, paused, completed
    description text,
    created_at timestamp
    with
        time zone default now()
);

-- Ensure columns exist for legacy project tables (Fixes "address column not found" error)
ALTER TABLE projects ADD COLUMN IF NOT EXISTS address text;

ALTER TABLE projects ADD COLUMN IF NOT EXISTS description text;

ALTER TABLE projects ADD COLUMN IF NOT EXISTS start_date date;

ALTER TABLE projects ADD COLUMN IF NOT EXISTS end_date date;

ALTER TABLE projects
ADD COLUMN IF NOT EXISTS status text default 'active';

-- [USERS] ------------------------------------------------------------
CREATE TABLE IF NOT EXISTS users (
    id bigint generated by default as identity primary key,
    username text unique not null,
    password text not null, -- Simple password for demo/internal app
    name text not null,
    role text not null default 'technician', -- super_admin, project_admin, site_manager, technician
    department text,
    assigned_projects jsonb default '[]'::jsonb, -- Stores array of project IDs
    created_at timestamptz default now()
);

-- [MACHINES] ---------------------------------------------------------
create table if not exists machines (
    id uuid default uuid_generate_v4 () primary key,
    code text not null unique,
    name text,
    model text,
    current_hours numeric default 0,
    status text check (
        status in (
            'active',
            'maintenance',
            'broken',
            'disposed'
        )
    ) default 'active',
    project_name text,
    description text,
    serial_number text,
    created_at timestamp
    with
        time zone default now(),
        updated_at timestamp
    with
        time zone default now(),
        -- Additional columns
        current_km numeric default 0,
        project_id bigint references projects (id) on delete set null
);
-- Ensure columns exist if table already existed
alter table machines add column if not exists project_name text;

alter table machines
add column if not exists current_km numeric default 0;

alter table machines add column if not exists project_id bigint;

alter table machines add column if not exists description text;

alter table machines add column if not exists serial_number text;

-- [MAINTENANCE STANDARDS] --------------------------------------------
create table if not exists maintenance_standards (
    id uuid default uuid_generate_v4 () primary key,
    model_ref text not null,
    interval_hours numeric not null,
    part_name text not null,
    note text,
    created_at timestamp
    with
        time zone default now()
);

-- [DAILY LOGS] -------------------------------------------------------
create table if not exists daily_logs (
    id uuid default uuid_generate_v4 () primary key,
    -- machine_id added dynamically below to match machines.id type
    date date default current_date not null,
    hours_added numeric not null check (hours_added >= 0),
    fuel_consumed numeric default 0,
    created_at timestamp
    with
        time zone default now(),
        odo_km numeric default 0,
        machine_code text,
        note text
);

-- Checks and fixes for numeric columns
DO $$
BEGIN
    IF EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'daily_logs' AND column_name = 'hours') THEN
        ALTER TABLE daily_logs RENAME COLUMN hours TO hours_added;
    END IF;
END $$;

alter table daily_logs
add column if not exists odo_km numeric default 0;

alter table daily_logs add column if not exists machine_code text;

alter table daily_logs add column if not exists note text;

-- [REPAIR HISTORY] (Primary Reporting Table) -------------------------
create table if not exists repair_history (
    id uuid default uuid_generate_v4 () primary key,
    -- machine_id added dynamically below
    description text,
    date date default current_date,
    cost numeric default 0,
    source text check (
        source in ('manual', 'vincons_bot')
    ) default 'manual',
    external_id text,
    created_at timestamp
    with
        time zone default now(),
        issue text,
        cause text,
        parts_ordered_date date,
        parts_arrived_date date,
        completed_date date,
        status text default 'pending',
        machine_code text
);

alter table repair_history add column if not exists issue text;

alter table repair_history add column if not exists cause text;

alter table repair_history
add column if not exists parts_ordered_date date;

alter table repair_history
add column if not exists parts_arrived_date date;

alter table repair_history
add column if not exists completed_date date;

alter table repair_history
add column if not exists status text default 'pending';

alter table repair_history
add column if not exists machine_code text;

-- DYNAMIC MACHINE_ID HANDLING (Fixes "type uuid vs bigint" error)
DO $$
DECLARE
    machine_id_type text;
BEGIN
    -- 1. Get the type of machines.id
    SELECT data_type INTO machine_id_type 
    FROM information_schema.columns 
    WHERE table_name = 'machines' AND column_name = 'id';

    -- Default to uuid if not found (shouldn't happen)
    IF machine_id_type IS NULL THEN
        machine_id_type := 'uuid';
    END IF;

    -- 2. Add machine_id to daily_logs with correct type
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'daily_logs' AND column_name = 'machine_id') THEN
        EXECUTE 'ALTER TABLE daily_logs ADD COLUMN machine_id ' || machine_id_type;
    END IF;

    -- 3. Add FK constraint for daily_logs
    IF NOT EXISTS (SELECT 1 FROM information_schema.table_constraints WHERE constraint_name = 'daily_logs_machine_id_fkey') THEN
        EXECUTE 'ALTER TABLE daily_logs ADD CONSTRAINT daily_logs_machine_id_fkey FOREIGN KEY (machine_id) REFERENCES machines(id) ON DELETE CASCADE';
    END IF;

    -- 4. Add machine_id to repair_history with correct type
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'repair_history' AND column_name = 'machine_id') THEN
        EXECUTE 'ALTER TABLE repair_history ADD COLUMN machine_id ' || machine_id_type;
    END IF;

    -- 5. Add FK constraint for repair_history
    IF NOT EXISTS (SELECT 1 FROM information_schema.table_constraints WHERE constraint_name = 'repair_history_machine_id_fkey') THEN
        EXECUTE 'ALTER TABLE repair_history ADD CONSTRAINT repair_history_machine_id_fkey FOREIGN KEY (machine_id) REFERENCES machines(id) ON DELETE CASCADE';
    END IF;
END $$;

-- 2. Backfill machine_id from machine_code if missing
-- Note: Logic is generic regardless of type
UPDATE daily_logs
SET
    machine_id = machines.id
FROM machines
WHERE
    daily_logs.machine_code = machines.code
    AND daily_logs.machine_id IS NULL;

UPDATE repair_history
SET
    machine_id = machines.id
FROM machines
WHERE
    repair_history.machine_code = machines.code
    AND repair_history.machine_id IS NULL;

-- [MAINTENANCE HISTORY] (Legacy/Detailed Technical Table) ------------
CREATE TABLE IF NOT EXISTS maintenance_history (
    id uuid DEFAULT gen_random_uuid () PRIMARY KEY,
    machine_code text, -- Loose link to machines.code
    date date DEFAULT CURRENT_DATE,
    hours_at_maintenance numeric,
    km_at_maintenance numeric,
    maintenance_level text, -- 'Bảo dưỡng định kỳ', 'Sửa chữa'
    task_name text,
    performer text,
    cost numeric DEFAULT 0,
    notes text,
    created_at timestamptz DEFAULT now()
);

-- [ERROR CODES] ------------------------------------------------------
CREATE TABLE IF NOT EXISTS error_codes (
    id bigint generated by default as identity primary key,
    code text not null unique,
    description text,
    fix_steps text,
    created_at timestamptz default now()
);

-- [PARTS] (Spare Parts) ----------------------------------------------
CREATE TABLE IF NOT EXISTS parts (
    id bigint generated by default as identity primary key,
    part_number text not null unique,
    name text,
    equivalents text,
    created_at timestamptz default now()
);

-- [NOTIFICATIONS] ----------------------------------------------------
create table if not exists notifications (
    id uuid default uuid_generate_v4 () primary key,
    project_name text,
    title text not null,
    message text,
    type text check (
        type in (
            'info',
            'warning',
            'error',
            'success'
        )
    ) default 'info',
    is_read boolean default false,
    created_at timestamp
    with
        time zone default now()
);

-- 3. CREATE INDEXES (Performance)
create index if not exists idx_machines_code on machines (code);

create index if not exists idx_daily_logs_machine_id on daily_logs (machine_id);

create index if not exists idx_repair_history_machine_id on repair_history (machine_id);

create index if not exists idx_repair_history_external_id on repair_history (external_id);

create index if not exists idx_notifications_project_name on notifications (project_name);

create index if not exists idx_notifications_is_read on notifications (is_read);

create index if not exists idx_maintenance_history_code on maintenance_history (machine_code);

-- 4. RLS POLICIES (Security)
-- Enable RLS on all tables
alter table projects enable row level security;

alter table users enable row level security;

alter table machines enable row level security;

alter table maintenance_standards enable row level security;

alter table daily_logs enable row level security;

alter table repair_history enable row level security;

alter table maintenance_history enable row level security;

alter table notifications enable row level security;

alter table error_codes enable row level security;

alter table parts enable row level security;

-- Clean existing policies to ensure clean state
DO $$ 
DECLARE 
  r RECORD; 
BEGIN 
  FOR r IN SELECT schemaname, tablename, policyname FROM pg_policies WHERE tablename IN ('projects', 'users', 'machines', 'daily_logs', 'repair_history', 'notifications', 'maintenance_history', 'parts', 'error_codes', 'maintenance_standards') 
  LOOP 
    EXECUTE 'DROP POLICY IF EXISTS "' || r.policyname || '" ON ' || quote_ident(r.tablename); 
  END LOOP; 
END $$;

-- Create OPEN Policies (Authenticated Users can Read/Write)
create policy "Enable all for auth" on projects for all using (true)
with
    check (true);

create policy "Enable all for auth" on users for all using (true)
with
    check (true);

create policy "Enable all for auth" on machines for all using (true)
with
    check (true);

create policy "Enable all for auth" on maintenance_standards for all using (true)
with
    check (true);

create policy "Enable all for auth" on daily_logs for all using (true)
with
    check (true);

create policy "Enable all for auth" on repair_history for all using (true)
with
    check (true);

create policy "Enable all for auth" on maintenance_history for all using (true)
with
    check (true);

create policy "Enable all for auth" on notifications for all using (true)
with
    check (true);

create policy "Enable all for auth" on error_codes for all using (true)
with
    check (true);

create policy "Enable all for auth" on parts for all using (true)
with
    check (true);

-- 5. AUTOMATION LOGIC

-- Trigger: Update Machine Hours/KM on Daily Log Insert
create or replace function update_machine_hours()
returns trigger as $$
begin
  if new.machine_id is not null then
      update machines
      set current_hours = current_hours + new.hours_added,
          updated_at = now()
      where id = new.machine_id;
  end if;
  return new;
end;
$$ language plpgsql;

drop trigger if exists trg_update_hours on daily_logs;

create trigger trg_update_hours
after insert on daily_logs
for each row
execute function update_machine_hours();

-- Function: UNIVERSAL IMPORT (Smart Import Handler)
CREATE OR REPLACE FUNCTION import_universal_data(payload jsonb)
RETURNS jsonb
LANGUAGE plpgsql
AS $$
DECLARE
    row_data jsonb;
    result_stats jsonb := '{"machines": 0, "logs": 0, "repairs": 0, "errors": 0, "details": []}'::jsonb;
    
    -- Variables for extraction
    p_code text;
    p_name text;
    p_model text;
    p_project text;
    p_status text;
    
    p_date date;
    p_hours numeric;
    p_fuel numeric;
    
    p_desc text;
    p_issue text;
    p_cause text;
    p_cost numeric;
    
    v_machine_id uuid;
    error_msg text;
BEGIN
    FOR row_data IN SELECT * FROM jsonb_array_elements(payload)
    LOOP
        BEGIN
            -- 1. DETECT TYPE: MACHINE LIST
            IF (row_data ? 'Mã tài sản' OR row_data ? 'Code') AND (row_data ? 'Tên thiết bị' OR row_data ? 'Model') AND NOT (row_data ? 'Ngày') THEN
                
                p_code := COALESCE(row_data->>'Mã tài sản', row_data->>'Code');
                p_name := COALESCE(row_data->>'Tên thiết bị', row_data->>'Name', 'N/A');
                p_model := COALESCE(row_data->>'Model', row_data->>'Kiểu máy');
                p_project := COALESCE(row_data->>'Dự án', row_data->>'Project');
                p_status := 'active'; 

                INSERT INTO machines (code, name, model, project_name, status)
                VALUES (p_code, p_name, p_model, p_project, p_status)
                ON CONFLICT (code) DO UPDATE 
                SET name = EXCLUDED.name, model = EXCLUDED.model, project_name = EXCLUDED.project_name;
                        
                result_stats := jsonb_set(result_stats, '{machines}', (result_stats->>'machines')::int + 1);

            -- 2. DETECT TYPE: DAILY LOG
            ELSIF (row_data ? 'Mã tài sản' OR row_data ? 'Code') AND (row_data ? 'Ngày' OR row_data ? 'Date') AND (row_data ? 'Giờ hoạt động' OR row_data ? 'Hours Added') THEN
                
                p_code := COALESCE(row_data->>'Mã tài sản', row_data->>'Code');
                p_date := (COALESCE(row_data->>'Ngày', row_data->>'Date'))::date;
                p_hours := (COALESCE(row_data->>'Giờ hoạt động', row_data->>'Hours Added', '0'))::numeric;
                
                -- Attempt to look up machine_id
                SELECT id INTO v_machine_id FROM machines WHERE code = p_code;

                IF v_machine_id IS NOT NULL THEN
                    INSERT INTO daily_logs (machine_id, date, hours_added, machine_code)
                    VALUES (v_machine_id, p_date, p_hours, p_code);
                    result_stats := jsonb_set(result_stats, '{logs}', (result_stats->>'logs')::int + 1);
                END IF;

            -- 3. DETECT TYPE: REPAIR
            ELSIF (row_data ? 'Tình trạng hỏng' OR row_data ? 'Issue' OR row_data ? 'Hạng mục sửa chữa') THEN
                 p_code := COALESCE(row_data->>'Mã tài sản', row_data->>'Code');
                 p_issue := COALESCE(row_data->>'Tình trạng hỏng', row_data->>'Issue');
                 p_cost := (COALESCE(row_data->>'Chi phí', '0'))::numeric;

                 SELECT id INTO v_machine_id FROM machines WHERE code = p_code;

                 IF v_machine_id IS NOT NULL THEN
                    INSERT INTO repair_history (machine_id, date, issue, cost, machine_code)
                    VALUES (v_machine_id, now()::date, p_issue, p_cost, p_code);
                    result_stats := jsonb_set(result_stats, '{repairs}', (result_stats->>'repairs')::int + 1);
                 END IF;
            END IF;

        EXCEPTION WHEN OTHERS THEN
            error_msg := SQLERRM;
            result_stats := jsonb_set(result_stats, '{errors}', (result_stats->>'errors')::int + 1);
        END;
    END LOOP;

    RETURN result_stats;
END;
$$;

-- 6. SEED DATA (IF EMPTY) --------------------------------------------

-- Users
INSERT INTO users (username, password, name, role, assigned_projects)
VALUES 
('admin', 'admin123', 'Administrator', 'super_admin', '[]'::jsonb)
ON CONFLICT (username) DO NOTHING;

-- Projects (Sample)
INSERT INTO
    projects (name, code, start_date)
VALUES (
        'Dự án Hòa Lạc',
        'DA-HL-01',
        '2024-01-01'
    ),
    (
        'Dự án Cầu Giấy',
        'DA-CG-02',
        '2024-02-15'
    ) ON CONFLICT DO NOTHING;

-- Error Codes (Sample)
INSERT INTO
    error_codes (code, description, fix_steps)
VALUES (
        'E001',
        'Quá nhiệt động cơ',
        'Kiểm tra nước làm mát và quạt gió.'
    ),
    (
        'E002',
        'Áp suất dầu thấp',
        'Kiểm tra mức dầu và bơm dầu.'
    ) ON CONFLICT (code) DO NOTHING;

-- Parts (Sample)
INSERT INTO
    parts (
        part_number,
        name,
        equivalents
    )
VALUES (
        'LF9009',
        'Lọc nhớt Fleetguard',
        'B7085, P553000'
    ),
    (
        'FF5488',
        'Lọc nhiên liệu',
        'P550881'
    ) ON CONFLICT (part_number) DO NOTHING;

-- AUTO-LINK MACHINES TO PROJECTS
UPDATE machines m
SET
    project_id = p.id
FROM projects p
WHERE
    m.project_name = p.name
    AND m.project_id IS NULL;

-- 7. MASS DATA GENERATION (10,000 MACHINES)
-- Only runs if machine count is low (e.g. < 10) to avoid duplicates or overwriting real data
DO $$
DECLARE
    existing_count integer;
    i integer;
    proj_id_list int[];
    rand_proj_id int;
BEGIN
    SELECT count(*) INTO existing_count FROM machines;
    
    -- Pick up project IDs to assign randomly
    SELECT array_agg(id) INTO proj_id_list FROM projects;

    IF existing_count < 10 THEN
        FOR i IN 1..10000 LOOP
            -- Random Project ID
            IF proj_id_list IS NOT NULL THEN
                rand_proj_id := proj_id_list[1 + floor(random() * array_length(proj_id_list, 1))::int];
            ELSE
                rand_proj_id := NULL;
            END IF;

            INSERT INTO machines (code, name, status, project_id, project_name, current_hours)
            VALUES (
                'M-' || LPAD(i::text, 5, '0'),
                'Máy Xúc ' || LPAD(i::text, 5, '0'),
                CASE floor(random() * 3)::int 
                    WHEN 0 THEN 'active' 
                    WHEN 1 THEN 'maintenance' 
                    ELSE 'idle' 
                END,
                rand_proj_id,
                (SELECT name FROM projects WHERE id = rand_proj_id),
                floor(random() * 5000)::numeric
            );
        END LOOP;
    END IF;
END $$;